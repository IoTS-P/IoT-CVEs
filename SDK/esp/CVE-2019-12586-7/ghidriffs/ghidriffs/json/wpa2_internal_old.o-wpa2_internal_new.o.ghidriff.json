{
    "program_options": {
        "wpa2_internal_old.o": {
            "Decompiler": {
                "Prototype Evaluation": "__stdcall"
            },
            "Specification Extensions": {
                "FormatVersion": "0",
                "VersionCounter": "0"
            },
            "Analyzers": {
                "ASCII Strings": "true",
                "ASCII Strings.Create Strings Containing Existing Strings": "true",
                "ASCII Strings.Create Strings Containing References": "true",
                "ASCII Strings.Force Model Reload": "false",
                "ASCII Strings.Minimum String Length": "LEN_5",
                "ASCII Strings.Model File": "StringModel.sng",
                "ASCII Strings.Require Null Termination for String": "true",
                "ASCII Strings.Search Only in Accessible Memory Blocks": "true",
                "ASCII Strings.String Start Alignment": "ALIGN_1",
                "ASCII Strings.String end alignment": "4",
                "Aggressive Instruction Finder": "false",
                "Aggressive Instruction Finder.Create Analysis Bookmarks": "true",
                "Apply Data Archives": "true",
                "Apply Data Archives.Archive Chooser": "[Auto-Detect]",
                "Apply Data Archives.Create Analysis Bookmarks": "true",
                "Apply Data Archives.GDT User File Archive Path": null,
                "Apply Data Archives.User Project Archive Path": null,
                "Basic Constant Reference Analyzer": "true",
                "Basic Constant Reference Analyzer.Create Data from pointer": "false",
                "Basic Constant Reference Analyzer.Function parameter/return Pointer analysis": "true",
                "Basic Constant Reference Analyzer.Max Threads": "2",
                "Basic Constant Reference Analyzer.Min absolute reference": "4",
                "Basic Constant Reference Analyzer.Require pointer param data type": "false",
                "Basic Constant Reference Analyzer.Speculative reference max": "256",
                "Basic Constant Reference Analyzer.Speculative reference min": "512",
                "Basic Constant Reference Analyzer.Stored Value Pointer analysis": "true",
                "Basic Constant Reference Analyzer.Trust values read from writable memory": "true",
                "Call Convention ID": "true",
                "Call Convention ID.Analysis Decompiler Timeout (sec)": "60",
                "Call-Fixup Installer": "true",
                "Condense Filler Bytes": "false",
                "Condense Filler Bytes.Filler Value": "Auto",
                "Condense Filler Bytes.Minimum number of sequential bytes": "1",
                "Create Address Tables": "true",
                "Create Address Tables.Allow Offcut References": "false",
                "Create Address Tables.Auto Label Table": "false",
                "Create Address Tables.Create Analysis Bookmarks": "true",
                "Create Address Tables.Maxmimum Pointer Distance": "16777215",
                "Create Address Tables.Minimum Pointer Address": "4132",
                "Create Address Tables.Minimum Table Size": "2",
                "Create Address Tables.Pointer Alignment": "1",
                "Create Address Tables.Relocation Table Guide": "true",
                "Create Address Tables.Table Alignment": "4",
                "Data Reference": "true",
                "Data Reference.Address Table Alignment": "1",
                "Data Reference.Address Table Minimum Size": "2",
                "Data Reference.Align End of Strings": "false",
                "Data Reference.Ascii String References": "true",
                "Data Reference.Create Address Tables": "false",
                "Data Reference.Minimum String Length": "5",
                "Data Reference.References to Pointers": "true",
                "Data Reference.Relocation Table Guide": "true",
                "Data Reference.Respect Execute Flag": "true",
                "Data Reference.Subroutine References": "true",
                "Data Reference.Switch Table References": "false",
                "Data Reference.Unicode String References": "true",
                "Decompiler Parameter ID": "false",
                "Decompiler Parameter ID.Analysis Clear Level": "ANALYSIS",
                "Decompiler Parameter ID.Analysis Decompiler Timeout (sec)": "60",
                "Decompiler Parameter ID.Commit Data Types": "true",
                "Decompiler Parameter ID.Commit Void Return Values": "false",
                "Decompiler Parameter ID.Prototype Evaluation": "__stdcall",
                "Decompiler Switch Analysis": "true",
                "Decompiler Switch Analysis.Analysis Decompiler Timeout (sec)": "60",
                "Demangler GNU": "true",
                "Demangler GNU.Apply Function Calling Conventions": "true",
                "Demangler GNU.Apply Function Signatures": "true",
                "Demangler GNU.Demangle Only Known Mangled Symbols": "false",
                "Demangler GNU.Demangler Format": "AUTO",
                "Demangler GNU.Use Deprecated Demangler": "false",
                "Disassemble Entry Points": "true",
                "Disassemble Entry Points.Respect Execute Flag": "true",
                "ELF Scalar Operand References": "true",
                "ELF Scalar Operand References.Relocation Table Guide": "true",
                "Embedded Media": "true",
                "Embedded Media.Create Analysis Bookmarks": "true",
                "External Entry References": "true",
                "External Symbol Resolver": "true",
                "Function Start Search": "true",
                "Function Start Search After Code": "true",
                "Function Start Search After Code.Bookmark Functions": "false",
                "Function Start Search After Code.Search Data Blocks": "false",
                "Function Start Search After Data": "true",
                "Function Start Search After Data.Bookmark Functions": "false",
                "Function Start Search After Data.Search Data Blocks": "false",
                "Function Start Search.Bookmark Functions": "false",
                "Function Start Search.Search Data Blocks": "false",
                "Non-Returning Functions - Discovered": "true",
                "Non-Returning Functions - Discovered.Create Analysis Bookmarks": "true",
                "Non-Returning Functions - Discovered.Function Non-return Threshold": "3",
                "Non-Returning Functions - Discovered.Repair Flow Damage": "true",
                "Non-Returning Functions - Known": "true",
                "Non-Returning Functions - Known.Create Analysis Bookmarks": "true",
                "Reference": "true",
                "Reference.Address Table Alignment": "1",
                "Reference.Address Table Minimum Size": "2",
                "Reference.Align End of Strings": "false",
                "Reference.Ascii String References": "true",
                "Reference.Create Address Tables": "false",
                "Reference.Minimum String Length": "5",
                "Reference.References to Pointers": "true",
                "Reference.Relocation Table Guide": "true",
                "Reference.Respect Execute Flag": "true",
                "Reference.Subroutine References": "true",
                "Reference.Switch Table References": "false",
                "Reference.Unicode String References": "true",
                "Shared Return Calls": "true",
                "Shared Return Calls.Allow Conditional Jumps": "false",
                "Shared Return Calls.Assume Contiguous Functions Only": "true",
                "Stack": "true",
                "Stack.Create Local Variables": "true",
                "Stack.Create Param Variables": "true",
                "Stack.useNewFunctionStackAnalysis": "true",
                "Subroutine References": "true",
                "Subroutine References.Create Thunks Early": "true",
                "Variadic Function Signature Override": "false",
                "Variadic Function Signature Override.Create Analysis Bookmarks": "false"
            },
            "Program Information": {
                "Analysis Times.Times": "0.625 seconds",
                "Analyzed": "true",
                "Compiler": "unknown",
                "Created With Ghidra Version": "11.0",
                "Date Created": "Fri Mar 29 20:03:41 CST 2024",
                "ELF File Type": "relocatable",
                "ELF Original Image Base": "0x0",
                "ELF Prelinked": "false",
                "Elf Comment[0]": "",
                "Elf Comment[1]": "GCC: (crosstool-NG crosstool-ng-1.22.0-78-g4b87650) 5.2.0",
                "Executable Format": "Executable and Linking Format (ELF)",
                "Executable Location": "/data/git/esp/CVE-2019-12586-7/ghidriffs/wpa2_internal_old.o",
                "Executable MD5": "f799e287e6642322ec8ca45689fcfd86",
                "Executable SHA256": "ee0a7f244216a70a2c43f1eeb28dd2cf182649ffa575290c976463e25910b69d",
                "FSRL": "file:///data/git/esp/CVE-2019-12586-7/ghidriffs/wpa2_internal_old.o?MD5=f799e287e6642322ec8ca45689fcfd86",
                "Preferred Root Namespace Category": "",
                "Relocatable": "true",
                "Should Ask To Analyze": "false"
            }
        },
        "wpa2_internal_new.o": {
            "Decompiler": {
                "Prototype Evaluation": "__stdcall"
            },
            "Specification Extensions": {
                "FormatVersion": "0",
                "VersionCounter": "0"
            },
            "Analyzers": {
                "ASCII Strings": "true",
                "ASCII Strings.Create Strings Containing Existing Strings": "true",
                "ASCII Strings.Create Strings Containing References": "true",
                "ASCII Strings.Force Model Reload": "false",
                "ASCII Strings.Minimum String Length": "LEN_5",
                "ASCII Strings.Model File": "StringModel.sng",
                "ASCII Strings.Require Null Termination for String": "true",
                "ASCII Strings.Search Only in Accessible Memory Blocks": "true",
                "ASCII Strings.String Start Alignment": "ALIGN_1",
                "ASCII Strings.String end alignment": "4",
                "Aggressive Instruction Finder": "false",
                "Aggressive Instruction Finder.Create Analysis Bookmarks": "true",
                "Apply Data Archives": "true",
                "Apply Data Archives.Archive Chooser": "[Auto-Detect]",
                "Apply Data Archives.Create Analysis Bookmarks": "true",
                "Apply Data Archives.GDT User File Archive Path": null,
                "Apply Data Archives.User Project Archive Path": null,
                "Basic Constant Reference Analyzer": "true",
                "Basic Constant Reference Analyzer.Create Data from pointer": "false",
                "Basic Constant Reference Analyzer.Function parameter/return Pointer analysis": "true",
                "Basic Constant Reference Analyzer.Max Threads": "2",
                "Basic Constant Reference Analyzer.Min absolute reference": "4",
                "Basic Constant Reference Analyzer.Require pointer param data type": "false",
                "Basic Constant Reference Analyzer.Speculative reference max": "256",
                "Basic Constant Reference Analyzer.Speculative reference min": "512",
                "Basic Constant Reference Analyzer.Stored Value Pointer analysis": "true",
                "Basic Constant Reference Analyzer.Trust values read from writable memory": "true",
                "Call Convention ID": "true",
                "Call Convention ID.Analysis Decompiler Timeout (sec)": "60",
                "Call-Fixup Installer": "true",
                "Condense Filler Bytes": "false",
                "Condense Filler Bytes.Filler Value": "Auto",
                "Condense Filler Bytes.Minimum number of sequential bytes": "1",
                "Create Address Tables": "true",
                "Create Address Tables.Allow Offcut References": "false",
                "Create Address Tables.Auto Label Table": "false",
                "Create Address Tables.Create Analysis Bookmarks": "true",
                "Create Address Tables.Maxmimum Pointer Distance": "16777215",
                "Create Address Tables.Minimum Pointer Address": "4132",
                "Create Address Tables.Minimum Table Size": "2",
                "Create Address Tables.Pointer Alignment": "1",
                "Create Address Tables.Relocation Table Guide": "true",
                "Create Address Tables.Table Alignment": "4",
                "Data Reference": "true",
                "Data Reference.Address Table Alignment": "1",
                "Data Reference.Address Table Minimum Size": "2",
                "Data Reference.Align End of Strings": "false",
                "Data Reference.Ascii String References": "true",
                "Data Reference.Create Address Tables": "false",
                "Data Reference.Minimum String Length": "5",
                "Data Reference.References to Pointers": "true",
                "Data Reference.Relocation Table Guide": "true",
                "Data Reference.Respect Execute Flag": "true",
                "Data Reference.Subroutine References": "true",
                "Data Reference.Switch Table References": "false",
                "Data Reference.Unicode String References": "true",
                "Decompiler Parameter ID": "false",
                "Decompiler Parameter ID.Analysis Clear Level": "ANALYSIS",
                "Decompiler Parameter ID.Analysis Decompiler Timeout (sec)": "60",
                "Decompiler Parameter ID.Commit Data Types": "true",
                "Decompiler Parameter ID.Commit Void Return Values": "false",
                "Decompiler Parameter ID.Prototype Evaluation": "__stdcall",
                "Decompiler Switch Analysis": "true",
                "Decompiler Switch Analysis.Analysis Decompiler Timeout (sec)": "60",
                "Demangler GNU": "true",
                "Demangler GNU.Apply Function Calling Conventions": "true",
                "Demangler GNU.Apply Function Signatures": "true",
                "Demangler GNU.Demangle Only Known Mangled Symbols": "false",
                "Demangler GNU.Demangler Format": "AUTO",
                "Demangler GNU.Use Deprecated Demangler": "false",
                "Disassemble Entry Points": "true",
                "Disassemble Entry Points.Respect Execute Flag": "true",
                "ELF Scalar Operand References": "true",
                "ELF Scalar Operand References.Relocation Table Guide": "true",
                "Embedded Media": "true",
                "Embedded Media.Create Analysis Bookmarks": "true",
                "External Entry References": "true",
                "External Symbol Resolver": "true",
                "Function Start Search": "true",
                "Function Start Search After Code": "true",
                "Function Start Search After Code.Bookmark Functions": "false",
                "Function Start Search After Code.Search Data Blocks": "false",
                "Function Start Search After Data": "true",
                "Function Start Search After Data.Bookmark Functions": "false",
                "Function Start Search After Data.Search Data Blocks": "false",
                "Function Start Search.Bookmark Functions": "false",
                "Function Start Search.Search Data Blocks": "false",
                "Non-Returning Functions - Discovered": "true",
                "Non-Returning Functions - Discovered.Create Analysis Bookmarks": "true",
                "Non-Returning Functions - Discovered.Function Non-return Threshold": "3",
                "Non-Returning Functions - Discovered.Repair Flow Damage": "true",
                "Non-Returning Functions - Known": "true",
                "Non-Returning Functions - Known.Create Analysis Bookmarks": "true",
                "Reference": "true",
                "Reference.Address Table Alignment": "1",
                "Reference.Address Table Minimum Size": "2",
                "Reference.Align End of Strings": "false",
                "Reference.Ascii String References": "true",
                "Reference.Create Address Tables": "false",
                "Reference.Minimum String Length": "5",
                "Reference.References to Pointers": "true",
                "Reference.Relocation Table Guide": "true",
                "Reference.Respect Execute Flag": "true",
                "Reference.Subroutine References": "true",
                "Reference.Switch Table References": "false",
                "Reference.Unicode String References": "true",
                "Shared Return Calls": "true",
                "Shared Return Calls.Allow Conditional Jumps": "false",
                "Shared Return Calls.Assume Contiguous Functions Only": "true",
                "Stack": "true",
                "Stack.Create Local Variables": "true",
                "Stack.Create Param Variables": "true",
                "Stack.useNewFunctionStackAnalysis": "true",
                "Subroutine References": "true",
                "Subroutine References.Create Thunks Early": "true",
                "Variadic Function Signature Override": "false",
                "Variadic Function Signature Override.Create Analysis Bookmarks": "false"
            },
            "Program Information": {
                "Analysis Times.Times": "0.669 seconds",
                "Analyzed": "true",
                "Compiler": "unknown",
                "Created With Ghidra Version": "11.0",
                "Date Created": "Fri Mar 29 20:03:42 CST 2024",
                "ELF File Type": "relocatable",
                "ELF Original Image Base": "0x0",
                "ELF Prelinked": "false",
                "Elf Comment[0]": "",
                "Elf Comment[1]": "GCC: (crosstool-NG crosstool-ng-1.22.0-78-g4b87650) 5.2.0",
                "Executable Format": "Executable and Linking Format (ELF)",
                "Executable Location": "/data/git/esp/CVE-2019-12586-7/ghidriffs/wpa2_internal_new.o",
                "Executable MD5": "91e0c69a6219f27347ebca041605dd87",
                "Executable SHA256": "1b744a64b6455bb94a50ae9689a7ef37f5f8b90262163e2fe8bed744d2583cee",
                "FSRL": "file:///data/git/esp/CVE-2019-12586-7/ghidriffs/wpa2_internal_new.o?MD5=91e0c69a6219f27347ebca041605dd87",
                "Preferred Root Namespace Category": "",
                "Relocatable": "true",
                "Should Ask To Analyze": "false"
            }
        }
    },
    "stats": {
        "added_funcs_len": 0,
        "deleted_funcs_len": 0,
        "modified_funcs_len": 4,
        "added_symbols_len": 0,
        "deleted_symbols_len": 0,
        "diff_time": 0.7095379829406738,
        "deleted_strings_len": 0,
        "added_strings_len": 0,
        "match_types": {
            "SymbolsHash": 10
        },
        "items_to_process": 4,
        "diff_types": {
            "code": 4,
            "length": 4,
            "address": 4
        },
        "unmatched_funcs_len": 0,
        "total_funcs_len": 20,
        "matched_funcs_len": 20,
        "matched_funcs_with_code_changes_len": 4,
        "matched_funcs_with_non_code_changes_len": 0,
        "matched_funcs_no_changes_len": 16,
        "match_func_similarity_percent": "80.0000%",
        "func_match_overall_percent": "100.0000%",
        "first_matches": {
            "SymbolsHash": 10
        }
    },
    "symbols": {
        "added": [],
        "deleted": []
    },
    "strings": {
        "added": [],
        "deleted": []
    },
    "functions": {
        "added": [],
        "deleted": [],
        "modified": [
            {
                "old": {
                    "name": "esp_wifi_sta_wpa2_ent_enable_fn",
                    "fullname": "esp_wifi_sta_wpa2_ent_enable_fn",
                    "parent": "Global",
                    "refcount": 1,
                    "length": 340,
                    "called": [],
                    "calling": [],
                    "paramcount": 0,
                    "address": "000105b8",
                    "sig": "undefined esp_wifi_sta_wpa2_ent_enable_fn(void)",
                    "code": "\nundefined4 esp_wifi_sta_wpa2_ent_enable_fn(int *param_1)\n\n{\n  undefined4 uVar1;\n  undefined4 *puVar2;\n  int iVar3;\n  code *pcVar4;\n  \n  if ((iRam00000000 != 0) && (pcVar4 = *(code **)(iRam00000000 + 0x11c), pcVar4 != (code *)0x0)) {\n    uVar1 = (**(code **)(iRam00000000 + 0x120))();\n    (*pcVar4)(3,8,0xc,uVar1,8,0);\n  }\n  puVar2 = (undefined4 *)(**(code **)(iRam00000000 + 0x140))(0x14);\n  if (puVar2 != (undefined4 *)0x0) {\n    *puVar2 = 0x14;\n    puVar2[1] = 4;\n    puVar2[2] = 4;\n    puVar2[3] = 0x54;\n    puVar2[4] = 0x24;\n    (*(code *)0x0)();\n    (*(code *)0x0)(0,0,100);\n    if (*param_1 == 0) {\n      if ((iRam00000000 != 0) && (pcVar4 = *(code **)(iRam00000000 + 0x11c), pcVar4 != (code *)0x0))\n      {\n        uVar1 = (**(code **)(iRam00000000 + 0x120))();\n        (*pcVar4)(1,8,0xb8,uVar1,8,0);\n        return 0xffffffff;\n      }\n    }\n    else {\n      (*(code *)0x0)(0,*param_1,100);\n      if ((iRam00000000 == 100) && (iRam00000004 == 1)) {\n        if ((pcRam00000044 != (code *)0x0) &&\n           (((iVar3 = (*pcRam00000044)(), iVar3 != 0 && (iRam00000000 != 0)) &&\n            (pcVar4 = *(code **)(iRam00000000 + 0x11c), pcVar4 != (code *)0x0)))) {\n          uVar1 = (**(code **)(iRam00000000 + 0x120))();\n          (*pcVar4)(1,8,0xf8,uVar1,8);\n        }\n        iRam00000000 = CONCAT31(iRam00000000._1_3_,1);\n        memw();\n        return 0;\n      }\n      if ((iRam00000000 != 0) && (pcVar4 = *(code **)(iRam00000000 + 0x11c), pcVar4 != (code *)0x0))\n      {\n        uVar1 = (**(code **)(iRam00000000 + 0x120))();\n        (*pcVar4)(1,8,0x68,uVar1,8,100,1,iRam00000000,iRam00000004);\n      }\n    }\n    return 0xffffffff;\n  }\n  if ((iRam00000000 != 0) && (pcVar4 = *(code **)(iRam00000000 + 0x11c), pcVar4 != (code *)0x0)) {\n    uVar1 = (**(code **)(iRam00000000 + 0x120))();\n    (*pcVar4)(1,8,0x40,uVar1,8);\n    return 0x101;\n  }\n  return 0x101;\n}\n\n",
                    "instructions": -2502615479871440886,
                    "mnemonics": -8360107883491200119,
                    "blocks": -4067466992272179102,
                    "sym_type": "Function",
                    "sym_source": "IMPORTED",
                    "external": false
                },
                "new": {
                    "name": "esp_wifi_sta_wpa2_ent_enable_fn",
                    "fullname": "esp_wifi_sta_wpa2_ent_enable_fn",
                    "parent": "Global",
                    "refcount": 1,
                    "length": 333,
                    "called": [],
                    "calling": [],
                    "paramcount": 0,
                    "address": "0001062c",
                    "sig": "undefined esp_wifi_sta_wpa2_ent_enable_fn(void)",
                    "code": "\nundefined4 esp_wifi_sta_wpa2_ent_enable_fn(int *param_1)\n\n{\n  undefined4 uVar1;\n  undefined4 *puVar2;\n  int iVar3;\n  code *pcVar4;\n  \n  if ((iRam00000000 != 0) && (pcVar4 = *(code **)(iRam00000000 + 0x11c), pcVar4 != (code *)0x0)) {\n    uVar1 = (**(code **)(iRam00000000 + 0x120))();\n    (*pcVar4)(3,8,0xc,uVar1,8,0);\n  }\n  puVar2 = (undefined4 *)(**(code **)(iRam00000000 + 0x140))(0x10);\n  if (puVar2 == (undefined4 *)0x0) {\n    if ((iRam00000000 != 0) && (pcVar4 = *(code **)(iRam00000000 + 0x11c), pcVar4 != (code *)0x0)) {\n      uVar1 = (**(code **)(iRam00000000 + 0x120))();\n      (*pcVar4)(1,8,0x40,uVar1,8);\n      return 0x101;\n    }\n    return 0x101;\n  }\n  *puVar2 = 0x14;\n  puVar2[1] = 4;\n  puVar2[2] = 0x58;\n  puVar2[3] = 0x24;\n  (*(code *)0x0)();\n  (*(code *)0x0)(0,0,100);\n  if (*param_1 == 0) {\n    if ((iRam00000000 != 0) && (pcVar4 = *(code **)(iRam00000000 + 0x11c), pcVar4 != (code *)0x0)) {\n      uVar1 = (**(code **)(iRam00000000 + 0x120))();\n      (*pcVar4)(1,8,0xb8,uVar1,8,0);\n      return 0xffffffff;\n    }\n  }\n  else {\n    (*(code *)0x0)(0,*param_1,100);\n    if ((iRam00000000 == 100) && (iRam00000004 == 1)) {\n      if ((pcRam00000044 != (code *)0x0) &&\n         (((iVar3 = (*pcRam00000044)(), iVar3 != 0 && (iRam00000000 != 0)) &&\n          (pcVar4 = *(code **)(iRam00000000 + 0x11c), pcVar4 != (code *)0x0)))) {\n        uVar1 = (**(code **)(iRam00000000 + 0x120))();\n        (*pcVar4)(1,8,0xf8,uVar1,8);\n      }\n      iRam00000000 = CONCAT31(iRam00000000._1_3_,1);\n      memw();\n      return 0;\n    }\n    if ((iRam00000000 != 0) && (pcVar4 = *(code **)(iRam00000000 + 0x11c), pcVar4 != (code *)0x0)) {\n      uVar1 = (**(code **)(iRam00000000 + 0x120))();\n      (*pcVar4)(1,8,0x68,uVar1,8,100,1,iRam00000000,iRam00000004);\n      return 0xffffffff;\n    }\n  }\n  return 0xffffffff;\n}\n\n",
                    "instructions": -3530944251001677724,
                    "mnemonics": -4811814577012196787,
                    "blocks": 1070104938487466132,
                    "sym_type": "Function",
                    "sym_source": "IMPORTED",
                    "external": false
                },
                "diff": "--- esp_wifi_sta_wpa2_ent_enable_fn\n+++ esp_wifi_sta_wpa2_ent_enable_fn\n@@ -1,59 +1,57 @@\n \n undefined4 esp_wifi_sta_wpa2_ent_enable_fn(int *param_1)\n \n {\n   undefined4 uVar1;\n   undefined4 *puVar2;\n   int iVar3;\n   code *pcVar4;\n   \n   if ((iRam00000000 != 0) && (pcVar4 = *(code **)(iRam00000000 + 0x11c), pcVar4 != (code *)0x0)) {\n     uVar1 = (**(code **)(iRam00000000 + 0x120))();\n     (*pcVar4)(3,8,0xc,uVar1,8,0);\n   }\n-  puVar2 = (undefined4 *)(**(code **)(iRam00000000 + 0x140))(0x14);\n-  if (puVar2 != (undefined4 *)0x0) {\n-    *puVar2 = 0x14;\n-    puVar2[1] = 4;\n-    puVar2[2] = 4;\n-    puVar2[3] = 0x54;\n-    puVar2[4] = 0x24;\n-    (*(code *)0x0)();\n-    (*(code *)0x0)(0,0,100);\n-    if (*param_1 == 0) {\n-      if ((iRam00000000 != 0) && (pcVar4 = *(code **)(iRam00000000 + 0x11c), pcVar4 != (code *)0x0))\n-      {\n-        uVar1 = (**(code **)(iRam00000000 + 0x120))();\n-        (*pcVar4)(1,8,0xb8,uVar1,8,0);\n-        return 0xffffffff;\n-      }\n+  puVar2 = (undefined4 *)(**(code **)(iRam00000000 + 0x140))(0x10);\n+  if (puVar2 == (undefined4 *)0x0) {\n+    if ((iRam00000000 != 0) && (pcVar4 = *(code **)(iRam00000000 + 0x11c), pcVar4 != (code *)0x0)) {\n+      uVar1 = (**(code **)(iRam00000000 + 0x120))();\n+      (*pcVar4)(1,8,0x40,uVar1,8);\n+      return 0x101;\n     }\n-    else {\n-      (*(code *)0x0)(0,*param_1,100);\n-      if ((iRam00000000 == 100) && (iRam00000004 == 1)) {\n-        if ((pcRam00000044 != (code *)0x0) &&\n-           (((iVar3 = (*pcRam00000044)(), iVar3 != 0 && (iRam00000000 != 0)) &&\n-            (pcVar4 = *(code **)(iRam00000000 + 0x11c), pcVar4 != (code *)0x0)))) {\n-          uVar1 = (**(code **)(iRam00000000 + 0x120))();\n-          (*pcVar4)(1,8,0xf8,uVar1,8);\n-        }\n-        iRam00000000 = CONCAT31(iRam00000000._1_3_,1);\n-        memw();\n-        return 0;\n-      }\n-      if ((iRam00000000 != 0) && (pcVar4 = *(code **)(iRam00000000 + 0x11c), pcVar4 != (code *)0x0))\n-      {\n-        uVar1 = (**(code **)(iRam00000000 + 0x120))();\n-        (*pcVar4)(1,8,0x68,uVar1,8,100,1,iRam00000000,iRam00000004);\n-      }\n-    }\n-    return 0xffffffff;\n-  }\n-  if ((iRam00000000 != 0) && (pcVar4 = *(code **)(iRam00000000 + 0x11c), pcVar4 != (code *)0x0)) {\n-    uVar1 = (**(code **)(iRam00000000 + 0x120))();\n-    (*pcVar4)(1,8,0x40,uVar1,8);\n     return 0x101;\n   }\n-  return 0x101;\n+  *puVar2 = 0x14;\n+  puVar2[1] = 4;\n+  puVar2[2] = 0x58;\n+  puVar2[3] = 0x24;\n+  (*(code *)0x0)();\n+  (*(code *)0x0)(0,0,100);\n+  if (*param_1 == 0) {\n+    if ((iRam00000000 != 0) && (pcVar4 = *(code **)(iRam00000000 + 0x11c), pcVar4 != (code *)0x0)) {\n+      uVar1 = (**(code **)(iRam00000000 + 0x120))();\n+      (*pcVar4)(1,8,0xb8,uVar1,8,0);\n+      return 0xffffffff;\n+    }\n+  }\n+  else {\n+    (*(code *)0x0)(0,*param_1,100);\n+    if ((iRam00000000 == 100) && (iRam00000004 == 1)) {\n+      if ((pcRam00000044 != (code *)0x0) &&\n+         (((iVar3 = (*pcRam00000044)(), iVar3 != 0 && (iRam00000000 != 0)) &&\n+          (pcVar4 = *(code **)(iRam00000000 + 0x11c), pcVar4 != (code *)0x0)))) {\n+        uVar1 = (**(code **)(iRam00000000 + 0x120))();\n+        (*pcVar4)(1,8,0xf8,uVar1,8);\n+      }\n+      iRam00000000 = CONCAT31(iRam00000000._1_3_,1);\n+      memw();\n+      return 0;\n+    }\n+    if ((iRam00000000 != 0) && (pcVar4 = *(code **)(iRam00000000 + 0x11c), pcVar4 != (code *)0x0)) {\n+      uVar1 = (**(code **)(iRam00000000 + 0x120))();\n+      (*pcVar4)(1,8,0x68,uVar1,8,100,1,iRam00000000,iRam00000004);\n+      return 0xffffffff;\n+    }\n+  }\n+  return 0xffffffff;\n }\n \n",
                "diff_type": [
                    "code",
                    "length",
                    "address"
                ],
                "ratio": 0.27,
                "i_ratio": 0.56,
                "m_ratio": 0.93,
                "b_ratio": 0.95,
                "match_types": [
                    "SymbolsHash"
                ]
            },
            {
                "old": {
                    "name": "wpa2_post",
                    "fullname": "wpa2_post",
                    "parent": "Global",
                    "refcount": 1,
                    "length": 250,
                    "called": [],
                    "calling": [],
                    "paramcount": 0,
                    "address": "0001078c",
                    "sig": "undefined wpa2_post(void)",
                    "code": "\n/* WARNING: Removing unreachable block (ram,0x00010866) */\n/* WARNING: Removing unreachable block (ram,0x0001086b) */\n\nundefined4 wpa2_post(int param_1,int param_2)\n\n{\n  int iVar1;\n  undefined4 uVar2;\n  int iVar3;\n  code *pcVar4;\n  char *pcVar5;\n  code *pcVar6;\n  int *local_30 [12];\n  \n  if (iRam00000000 != 0) {\n    pcVar5 = (char *)(iRam00000000 + param_1 + 0xaf);\n    if (*pcVar5 != '\\0') {\n      return 0;\n    }\n    local_30[0] = (int *)(**(code **)(iRam00000000 + 0x134))(8);\n    iVar3 = iRam00000000;\n    if (local_30[0] == (int *)0x0) {\n      if ((iRam00000000 != 0) && (pcVar4 = *(code **)(iRam00000000 + 0x11c), pcVar4 != (code *)0x0))\n      {\n        uVar2 = (**(code **)(iRam00000000 + 0x120))();\n        (*pcVar4)(1,8,0x15c,uVar2,8);\n      }\n    }\n    else {\n      *pcVar5 = *pcVar5 + '\\x01';\n      iVar1 = iRam00000000;\n      memw();\n      pcVar6 = *(code **)(iVar3 + 0x90);\n      *local_30[0] = param_1;\n      local_30[0][1] = param_2;\n      pcVar4 = *(code **)(iVar3 + 0x54);\n      uVar2 = (*pcVar6)(10);\n      iVar3 = (*pcVar4)(iVar1,local_30,uVar2);\n      if (iVar3 == 1) {\n        if (iRam00000000 != 0) {\n          (**(code **)(iRam00000000 + 0x2c))(iRam00000000,0xffffffff);\n        }\n        return 0;\n      }\n      if ((iRam00000000 != 0) && (pcVar4 = *(code **)(iRam00000000 + 0x11c), pcVar4 != (code *)0x0))\n      {\n        uVar2 = (**(code **)(iRam00000000 + 0x120))();\n        (*pcVar4)(1,8,0x178,uVar2,8);\n      }\n    }\n  }\n  return 1;\n}\n\n",
                    "instructions": -287414920941697429,
                    "mnemonics": -6242996784527774950,
                    "blocks": -8989786833072733336,
                    "sym_type": "Function",
                    "sym_source": "IMPORTED",
                    "external": false
                },
                "new": {
                    "name": "wpa2_post",
                    "fullname": "wpa2_post",
                    "parent": "Global",
                    "refcount": 1,
                    "length": 255,
                    "called": [],
                    "calling": [],
                    "paramcount": 0,
                    "address": "000107fc",
                    "sig": "undefined wpa2_post(void)",
                    "code": "\n/* WARNING: Removing unreachable block (ram,0x000108da) */\n/* WARNING: Removing unreachable block (ram,0x000108df) */\n\nundefined4 wpa2_post(int param_1,int param_2)\n\n{\n  int iVar1;\n  int iVar2;\n  code *pcVar3;\n  char *pcVar4;\n  undefined4 uVar5;\n  code *pcVar6;\n  int *local_30 [12];\n  \n  uVar5 = 0xffffffff;\n  if (iRam00000000 != 0) {\n    pcVar4 = (char *)(iRam00000000 + param_1 + 0xaf);\n    uVar5 = 0;\n    if (*pcVar4 == '\\0') {\n      local_30[0] = (int *)(**(code **)(iRam00000000 + 0x134))(8);\n      iVar2 = iRam00000000;\n      if (local_30[0] == (int *)0x0) {\n        if ((iRam00000000 != 0) &&\n           (pcVar3 = *(code **)(iRam00000000 + 0x11c), pcVar3 != (code *)0x0)) {\n          uVar5 = (**(code **)(iRam00000000 + 0x120))();\n          (*pcVar3)(1,8,0x15c,uVar5,8);\n        }\n      }\n      else {\n        *pcVar4 = *pcVar4 + '\\x01';\n        iVar1 = iRam00000000;\n        memw();\n        pcVar6 = *(code **)(iVar2 + 0x90);\n        *local_30[0] = param_1;\n        local_30[0][1] = param_2;\n        pcVar3 = *(code **)(iVar2 + 0x54);\n        uVar5 = (*pcVar6)(10);\n        iVar2 = (*pcVar3)(iVar1,local_30,uVar5);\n        if (iVar2 == 1) {\n          if (iRam00000000 != 0) {\n            (**(code **)(iRam00000000 + 0x2c))(iRam00000000,0xffffffff);\n          }\n          return 0;\n        }\n        if ((iRam00000000 != 0) &&\n           (pcVar3 = *(code **)(iRam00000000 + 0x11c), pcVar3 != (code *)0x0)) {\n          uVar5 = (**(code **)(iRam00000000 + 0x120))();\n          (*pcVar3)(1,8,0x178,uVar5,8);\n        }\n      }\n      uVar5 = 0xffffffff;\n    }\n  }\n  return uVar5;\n}\n\n",
                    "instructions": 1922486797702608040,
                    "mnemonics": -5407752144593936689,
                    "blocks": -4906755052431970375,
                    "sym_type": "Function",
                    "sym_source": "IMPORTED",
                    "external": false
                },
                "diff": "--- wpa2_post\n+++ wpa2_post\n@@ -1,55 +1,57 @@\n \n-/* WARNING: Removing unreachable block (ram,0x00010866) */\n-/* WARNING: Removing unreachable block (ram,0x0001086b) */\n+/* WARNING: Removing unreachable block (ram,0x000108da) */\n+/* WARNING: Removing unreachable block (ram,0x000108df) */\n \n undefined4 wpa2_post(int param_1,int param_2)\n \n {\n   int iVar1;\n-  undefined4 uVar2;\n-  int iVar3;\n-  code *pcVar4;\n-  char *pcVar5;\n+  int iVar2;\n+  code *pcVar3;\n+  char *pcVar4;\n+  undefined4 uVar5;\n   code *pcVar6;\n   int *local_30 [12];\n   \n+  uVar5 = 0xffffffff;\n   if (iRam00000000 != 0) {\n-    pcVar5 = (char *)(iRam00000000 + param_1 + 0xaf);\n-    if (*pcVar5 != '\\0') {\n-      return 0;\n-    }\n-    local_30[0] = (int *)(**(code **)(iRam00000000 + 0x134))(8);\n-    iVar3 = iRam00000000;\n-    if (local_30[0] == (int *)0x0) {\n-      if ((iRam00000000 != 0) && (pcVar4 = *(code **)(iRam00000000 + 0x11c), pcVar4 != (code *)0x0))\n-      {\n-        uVar2 = (**(code **)(iRam00000000 + 0x120))();\n-        (*pcVar4)(1,8,0x15c,uVar2,8);\n+    pcVar4 = (char *)(iRam00000000 + param_1 + 0xaf);\n+    uVar5 = 0;\n+    if (*pcVar4 == '\\0') {\n+      local_30[0] = (int *)(**(code **)(iRam00000000 + 0x134))(8);\n+      iVar2 = iRam00000000;\n+      if (local_30[0] == (int *)0x0) {\n+        if ((iRam00000000 != 0) &&\n+           (pcVar3 = *(code **)(iRam00000000 + 0x11c), pcVar3 != (code *)0x0)) {\n+          uVar5 = (**(code **)(iRam00000000 + 0x120))();\n+          (*pcVar3)(1,8,0x15c,uVar5,8);\n+        }\n       }\n-    }\n-    else {\n-      *pcVar5 = *pcVar5 + '\\x01';\n-      iVar1 = iRam00000000;\n-      memw();\n-      pcVar6 = *(code **)(iVar3 + 0x90);\n-      *local_30[0] = param_1;\n-      local_30[0][1] = param_2;\n-      pcVar4 = *(code **)(iVar3 + 0x54);\n-      uVar2 = (*pcVar6)(10);\n-      iVar3 = (*pcVar4)(iVar1,local_30,uVar2);\n-      if (iVar3 == 1) {\n-        if (iRam00000000 != 0) {\n-          (**(code **)(iRam00000000 + 0x2c))(iRam00000000,0xffffffff);\n+      else {\n+        *pcVar4 = *pcVar4 + '\\x01';\n+        iVar1 = iRam00000000;\n+        memw();\n+        pcVar6 = *(code **)(iVar2 + 0x90);\n+        *local_30[0] = param_1;\n+        local_30[0][1] = param_2;\n+        pcVar3 = *(code **)(iVar2 + 0x54);\n+        uVar5 = (*pcVar6)(10);\n+        iVar2 = (*pcVar3)(iVar1,local_30,uVar5);\n+        if (iVar2 == 1) {\n+          if (iRam00000000 != 0) {\n+            (**(code **)(iRam00000000 + 0x2c))(iRam00000000,0xffffffff);\n+          }\n+          return 0;\n         }\n-        return 0;\n+        if ((iRam00000000 != 0) &&\n+           (pcVar3 = *(code **)(iRam00000000 + 0x11c), pcVar3 != (code *)0x0)) {\n+          uVar5 = (**(code **)(iRam00000000 + 0x120))();\n+          (*pcVar3)(1,8,0x178,uVar5,8);\n+        }\n       }\n-      if ((iRam00000000 != 0) && (pcVar4 = *(code **)(iRam00000000 + 0x11c), pcVar4 != (code *)0x0))\n-      {\n-        uVar2 = (**(code **)(iRam00000000 + 0x120))();\n-        (*pcVar4)(1,8,0x178,uVar2,8);\n-      }\n+      uVar5 = 0xffffffff;\n     }\n   }\n-  return 1;\n+  return uVar5;\n }\n \n",
                "diff_type": [
                    "code",
                    "length",
                    "address"
                ],
                "ratio": 0.26,
                "i_ratio": 0.67,
                "m_ratio": 0.97,
                "b_ratio": 0.98,
                "match_types": [
                    "SymbolsHash"
                ]
            },
            {
                "old": {
                    "name": "wpa2Task",
                    "fullname": "wpa2Task",
                    "parent": "Global",
                    "refcount": 1,
                    "length": 756,
                    "called": [],
                    "calling": [],
                    "paramcount": 0,
                    "address": "000110ac",
                    "sig": "undefined wpa2Task(void)",
                    "code": "\n/* WARNING: Removing unreachable block (ram,0x00011356) */\n/* WARNING: Removing unreachable block (ram,0x0001135b) */\n/* WARNING: Removing unreachable block (ram,0x00011326) */\n/* WARNING: Removing unreachable block (ram,0x0001132c) */\n\nvoid wpa2Task(void)\n\n{\n  code cVar1;\n  code *pcVar2;\n  int iVar3;\n  code *pcVar4;\n  undefined4 uVar5;\n  int iVar6;\n  uint uVar7;\n  code *pcVar8;\n  undefined auStack_40 [8];\n  code *pcStack_38;\n  int *piStack_34;\n  int iStack_30;\n  code *pcStack_2c;\n  code *pcStack_28;\n  \n  pcVar2 = pcRam00000000;\n  if (pcRam00000000 == (code *)0x0) {\n    return;\n  }\n  do {\n    iVar3 = (**(code **)(pcRam00000000 + 100))(pcRam00000000,&piStack_34,0xffffffff);\n    pcVar8 = pcRam00000000;\n    if (iVar3 == 1) {\n      iVar3 = *piStack_34;\n      if (iVar3 == 1) {\n        pcVar2[0xb0] = (code)((char)pcVar2[0xb0] + -1);\n        memw();\n        iVar3 = piStack_34[1];\n        if (iVar3 != 0) {\n          pcVar8 = *(code **)(iVar3 + 0xc);\n          if ((7 < *(uint *)(iVar3 + 0x10)) &&\n             (uVar7 = (uint)(pcRam00000000 == (code *)0x0), pcRam00000000 != (code *)0x0)) {\n            if (pcVar8[1] == (code)0x0) {\n              uVar7 = *(uint *)(iVar3 + 0x10) - 4;\n              if ((CONCAT11(pcVar8[2],pcVar8[3]) < 4) || (uVar7 < CONCAT11(pcVar8[2],pcVar8[3]))) {\nLAB_000112e2:\n                uVar7 = 0;\n              }\n              else {\n                pcStack_28 = pcRam00000000;\n                pcStack_2c = pcVar8;\n                (*(code *)0x0)(0,0x45c,pcVar8);\n                cVar1 = pcStack_2c[4];\n                if (cVar1 == (code)0x3) {\n                  (*(code *)0x0)(*(undefined4 *)(pcStack_28 + 0xbc));\n                  (**(code **)(pcRam00000000 + 0xa0))(*(undefined4 *)(pcStack_28 + 0xbc));\n                  pcVar8 = pcRam00000000;\n                  *(undefined4 *)(pcStack_28 + 0xbc) = 0;\n                  if ((pcVar8 != (code *)0x0) && (*(code **)(pcVar8 + 0x11c) != (code *)0x0)) {\n                    pcStack_2c = *(code **)(pcVar8 + 0x11c);\n                    uVar5 = (**(code **)(pcVar8 + 0x120))();\n                    (*pcStack_2c)(3,8,0x478,uVar5,8);\n                  }\n                  uVar7 = 0;\n                  pcStack_28[0xb2] = (code)0x1;\n                  memw();\n                }\n                else if (cVar1 == (code)0x4) {\n                  if ((pcRam00000000 != (code *)0x0) &&\n                     (*(code **)(pcRam00000000 + 0x11c) != (code *)0x0)) {\n                    pcStack_2c = *(code **)(pcRam00000000 + 0x11c);\n                    uVar5 = (**(code **)(pcRam00000000 + 0x120))();\n                    (*pcStack_2c)(3,8,0x498,uVar5,8);\n                  }\n                  uVar7 = 0;\n                  pcStack_28[0xb2] = (code)0x2;\n                  memw();\n                }\n                else {\n                  if (cVar1 != (code)0x1) goto LAB_000112e2;\n                  uVar7 = (*(code *)0x0)(pcStack_2c + 4,uVar7);\n                  (*(code *)0x0)(pcStack_28,uVar7);\n                }\n              }\n            }\n            (*(code *)0x0)(uVar7);\n            pcVar8 = *(code **)(iVar3 + 0xc);\n          }\n          (**(code **)(pcRam00000000 + 0xa0))(pcVar8);\n          (**(code **)(pcRam00000000 + 0xa0))(iVar3);\n        }\n      }\n      else {\n        if (iVar3 != 0) {\n          if (iVar3 == 2) {\n            (**(code **)(pcRam00000000 + 0xa0))();\n            (**(code **)(pcRam00000000 + 0x50))(pcRam00000000);\n            pcVar2 = pcRam00000000;\n            pcRam00000000 = (code *)0x0;\n            if (pcVar2 != (code *)0x0) {\n              (*pcRam00000030)();\n            }\n            (**(code **)((int)pcRam00000000 + 0x88))(0);\n            return;\n          }\n          (**(code **)(pcRam00000000 + 0xa0))();\n          goto LAB_00011311;\n        }\n        pcVar2[0xaf] = (code)((char)pcVar2[0xaf] + -1);\n        memw();\n        if (pcVar8 != (code *)0x0) {\n          pcVar4 = (code *)(*(code *)0x0)(auStack_40);\n          if (pcVar4 == (code *)0x0) {\n            pcStack_28 = pcVar4;\n            iVar3 = (*(code *)0x0)(pcVar8,1,0x458,0,&pcStack_38,0);\n            if (iVar3 != 0) {\n              iStack_30 = iVar3;\n              (*(code *)0x0)(4);\n              iVar3 = iStack_30;\n              iVar6 = iStack_30 + -0xe;\n              pcStack_2c = pcStack_38;\n              (*(code *)0x0)(iVar6,auStack_40,6);\n              (*(code *)0x0)(iStack_30 + -8,pcVar8 + 0xa9,6);\n              *(undefined *)(iVar3 + -2) = 0x88;\n              *(undefined *)(iVar3 + -1) = 0x8e;\n              memw();\n              (*(code *)0x0)(pcStack_28,iVar6,(uint)(pcStack_2c + 0xe) & 0xffff);\n              (**(code **)(pcRam00000000 + 0xa0))(iVar6);\n            }\n          }\n          else if ((pcRam00000000 != (code *)0x0) &&\n                  (*(code **)(pcRam00000000 + 0x11c) != (code *)0x0)) {\n            pcStack_28 = *(code **)(pcRam00000000 + 0x11c);\n            uVar5 = (**(code **)(pcRam00000000 + 0x120))();\n            (*pcStack_28)(1,8,0x43c,uVar5,8);\n          }\n        }\n      }\n      (**(code **)(pcRam00000000 + 0xa0))(piStack_34);\n    }\nLAB_00011311:\n    if (pcRam00000000 != (code *)0x0) {\n      (**(code **)(pcRam00000000 + 0x30))();\n    }\n  } while( true );\n}\n\n",
                    "instructions": -9000997584966010196,
                    "mnemonics": 4998278806293019794,
                    "blocks": 2652561920242769212,
                    "sym_type": "Function",
                    "sym_source": "IMPORTED",
                    "external": false
                },
                "new": {
                    "name": "wpa2Task",
                    "fullname": "wpa2Task",
                    "parent": "Global",
                    "refcount": 1,
                    "length": 822,
                    "called": [],
                    "calling": [],
                    "paramcount": 0,
                    "address": "000111d8",
                    "sig": "undefined wpa2Task(void)",
                    "code": "\n/* WARNING: Removing unreachable block (ram,0x000114c2) */\n/* WARNING: Removing unreachable block (ram,0x000114c7) */\n/* WARNING: Removing unreachable block (ram,0x00011492) */\n/* WARNING: Removing unreachable block (ram,0x00011498) */\n\nvoid wpa2Task(void)\n\n{\n  char cVar1;\n  int iVar2;\n  int iVar3;\n  int iVar4;\n  int iVar5;\n  undefined4 uVar6;\n  code *pcVar7;\n  code *pcVar8;\n  undefined auStack_40 [8];\n  code *pcStack_38;\n  int *piStack_34;\n  code *pcStack_30;\n  int iStack_2c;\n  \n  iVar2 = iRam00000000;\n  if (iRam00000000 == 0) {\n    return;\n  }\n  do {\n    iVar3 = (**(code **)(iRam00000000 + 100))(iRam00000000,&piStack_34,0xffffffff);\n    iVar5 = iRam00000000;\n    if (iVar3 == 1) {\n      iVar3 = *piStack_34;\n      if (iVar3 == 1) {\n        *(char *)(iVar2 + 0xb0) = *(char *)(iVar2 + 0xb0) + -1;\n        memw();\n        iVar5 = piStack_34[1];\n        if (iVar5 != 0) {\n          iVar3 = *(int *)(iVar5 + 0xc);\n          if ((7 < *(uint *)(iVar5 + 0x10)) && (iRam00000000 != 0)) {\n            if (*(char *)(iVar3 + 1) == '\\0') {\n              pcVar8 = (code *)(*(uint *)(iVar5 + 0x10) - 4);\n              pcVar7 = (code *)(uint)CONCAT11(*(undefined *)(iVar3 + 2),*(undefined *)(iVar3 + 3));\n              if ((pcVar7 < (code *)0x4) || (pcVar8 < pcVar7)) goto LAB_0001144e;\n              iStack_2c = iRam00000000;\n              pcStack_30 = pcVar8;\n              (*(code *)0x0)(0,0x490,iVar3);\n              cVar1 = *(char *)(iVar3 + 4);\n              if (cVar1 == '\\x03') {\n                if (*(int *)(iStack_2c + 0xbc) == 0) {\n                  if ((iRam00000000 != 0) && (*(code **)(iRam00000000 + 0x11c) != (code *)0x0)) {\n                    pcStack_30 = *(code **)(iRam00000000 + 0x11c);\n                    uVar6 = (**(code **)(iRam00000000 + 0x120))();\n                    (*pcStack_30)(3,8,0x4cc,uVar6,8);\n                  }\n                  goto LAB_00011430;\n                }\n                (*(code *)0x0)();\n                (**(code **)(iRam00000000 + 0xa0))(*(undefined4 *)(iStack_2c + 0xbc));\n                iVar3 = iRam00000000;\n                *(undefined4 *)(iStack_2c + 0xbc) = 0;\n                if ((iVar3 != 0) && (*(code **)(iVar3 + 0x11c) != (code *)0x0)) {\n                  pcStack_30 = *(code **)(iVar3 + 0x11c);\n                  uVar6 = (**(code **)(iVar3 + 0x120))();\n                  (*pcStack_30)(3,8,0x4ac,uVar6,8);\n                }\n                if (iRam00000000 != 0) {\n                  *(undefined *)(iRam00000000 + 0xb2) = 2;\n                  memw();\n                  (*(code *)0x0)(2);\n                  uVar6 = 0;\n                  goto LAB_00011450;\n                }\n                goto LAB_0001144e;\n              }\n              if (cVar1 == '\\x04') {\n                if ((iRam00000000 != 0) && (*(code **)(iRam00000000 + 0x11c) != (code *)0x0)) {\n                  pcStack_30 = *(code **)(iRam00000000 + 0x11c);\n                  uVar6 = (**(code **)(iRam00000000 + 0x120))();\n                  (*pcStack_30)(3,8,0x524,uVar6,8);\n                }\nLAB_00011430:\n                if (iRam00000000 == 0) goto LAB_0001144e;\n                *(undefined *)(iRam00000000 + 0xb2) = 3;\n                memw();\n                (*(code *)0x0)(3);\n                uVar6 = 0;\n              }\n              else {\n                if (cVar1 != '\\x01') goto LAB_0001144e;\n                uVar6 = (*(code *)0x0)(iVar3 + 4,pcStack_30);\n                (*(code *)0x0)(iStack_2c,uVar6);\n              }\n            }\n            else {\nLAB_0001144e:\n              uVar6 = 0;\n            }\nLAB_00011450:\n            (*(code *)0x0)(uVar6);\n            iVar3 = *(int *)(iVar5 + 0xc);\n          }\n          (**(code **)(iRam00000000 + 0xa0))(iVar3);\n          (**(code **)(iRam00000000 + 0xa0))(iVar5);\n        }\nLAB_000114ea:\n        (**(code **)(iRam00000000 + 0xa0))(piStack_34);\n      }\n      else {\n        if (iVar3 == 0) {\n          *(char *)(iVar2 + 0xaf) = *(char *)(iVar2 + 0xaf) + -1;\n          memw();\n          if (iVar5 != 0) {\n            iVar3 = (*(code *)0x0)(auStack_40);\n            if (iVar3 == 0) {\n              iVar3 = (*(code *)0x0)(iVar5,1,0x48c,0,&pcStack_38,0);\n              if (iVar3 != 0) {\n                if (iRam00000000 != 0) {\n                  *(undefined *)(iRam00000000 + 0xb2) = 1;\n                  iStack_2c = iVar3;\n                  (*(code *)0x0)(1);\n                  iVar3 = iStack_2c;\n                }\n                iVar4 = iVar3 + -0xe;\n                pcStack_30 = pcStack_38;\n                iStack_2c = iVar3;\n                (*(code *)0x0)(iVar4,auStack_40,6);\n                (*(code *)0x0)(iStack_2c + -8,iVar5 + 0xa9,6);\n                *(undefined *)(iVar3 + -2) = 0x88;\n                *(undefined *)(iVar3 + -1) = 0x8e;\n                memw();\n                (*(code *)0x0)(0,iVar4,(uint)(pcStack_30 + 0xe) & 0xffff);\n                (**(code **)(iRam00000000 + 0xa0))(iVar4);\n              }\n            }\n            else if ((iRam00000000 != 0) && (*(code **)(iRam00000000 + 0x11c) != (code *)0x0)) {\n              pcStack_30 = *(code **)(iRam00000000 + 0x11c);\n              uVar6 = (**(code **)(iRam00000000 + 0x120))();\n              (*pcStack_30)(1,8,0x470,uVar6,8);\n            }\n          }\n          goto LAB_000114ea;\n        }\n        if (iVar3 == 2) {\n          (**(code **)(iRam00000000 + 0xa0))();\n          (**(code **)(iRam00000000 + 0x50))(iRam00000000);\n          iVar2 = iRam00000000;\n          iRam00000000 = 0;\n          if (iVar2 != 0) {\n            (*pcRam00000030)();\n          }\n          (**(code **)(iRam00000000 + 0x88))(0);\n          return;\n        }\n        (**(code **)(iRam00000000 + 0xa0))();\n      }\n    }\n    if (iRam00000000 != 0) {\n      (**(code **)(iRam00000000 + 0x30))();\n    }\n  } while( true );\n}\n\n",
                    "instructions": 7878602760717363381,
                    "mnemonics": 2531553187151839706,
                    "blocks": 3957564924800611212,
                    "sym_type": "Function",
                    "sym_source": "IMPORTED",
                    "external": false
                },
                "diff": "--- wpa2Task\n+++ wpa2Task\n@@ -1,146 +1,162 @@\n \n-/* WARNING: Removing unreachable block (ram,0x00011356) */\n-/* WARNING: Removing unreachable block (ram,0x0001135b) */\n-/* WARNING: Removing unreachable block (ram,0x00011326) */\n-/* WARNING: Removing unreachable block (ram,0x0001132c) */\n+/* WARNING: Removing unreachable block (ram,0x000114c2) */\n+/* WARNING: Removing unreachable block (ram,0x000114c7) */\n+/* WARNING: Removing unreachable block (ram,0x00011492) */\n+/* WARNING: Removing unreachable block (ram,0x00011498) */\n \n void wpa2Task(void)\n \n {\n-  code cVar1;\n-  code *pcVar2;\n+  char cVar1;\n+  int iVar2;\n   int iVar3;\n-  code *pcVar4;\n-  undefined4 uVar5;\n-  int iVar6;\n-  uint uVar7;\n+  int iVar4;\n+  int iVar5;\n+  undefined4 uVar6;\n+  code *pcVar7;\n   code *pcVar8;\n   undefined auStack_40 [8];\n   code *pcStack_38;\n   int *piStack_34;\n-  int iStack_30;\n-  code *pcStack_2c;\n-  code *pcStack_28;\n+  code *pcStack_30;\n+  int iStack_2c;\n   \n-  pcVar2 = pcRam00000000;\n-  if (pcRam00000000 == (code *)0x0) {\n+  iVar2 = iRam00000000;\n+  if (iRam00000000 == 0) {\n     return;\n   }\n   do {\n-    iVar3 = (**(code **)(pcRam00000000 + 100))(pcRam00000000,&piStack_34,0xffffffff);\n-    pcVar8 = pcRam00000000;\n+    iVar3 = (**(code **)(iRam00000000 + 100))(iRam00000000,&piStack_34,0xffffffff);\n+    iVar5 = iRam00000000;\n     if (iVar3 == 1) {\n       iVar3 = *piStack_34;\n       if (iVar3 == 1) {\n-        pcVar2[0xb0] = (code)((char)pcVar2[0xb0] + -1);\n+        *(char *)(iVar2 + 0xb0) = *(char *)(iVar2 + 0xb0) + -1;\n         memw();\n-        iVar3 = piStack_34[1];\n-        if (iVar3 != 0) {\n-          pcVar8 = *(code **)(iVar3 + 0xc);\n-          if ((7 < *(uint *)(iVar3 + 0x10)) &&\n-             (uVar7 = (uint)(pcRam00000000 == (code *)0x0), pcRam00000000 != (code *)0x0)) {\n-            if (pcVar8[1] == (code)0x0) {\n-              uVar7 = *(uint *)(iVar3 + 0x10) - 4;\n-              if ((CONCAT11(pcVar8[2],pcVar8[3]) < 4) || (uVar7 < CONCAT11(pcVar8[2],pcVar8[3]))) {\n-LAB_0:\n-                uVar7 = 0;\n+        iVar5 = piStack_34[1];\n+        if (iVar5 != 0) {\n+          iVar3 = *(int *)(iVar5 + 0xc);\n+          if ((7 < *(uint *)(iVar5 + 0x10)) && (iRam00000000 != 0)) {\n+            if (*(char *)(iVar3 + 1) == '\\0') {\n+              pcVar8 = (code *)(*(uint *)(iVar5 + 0x10) - 4);\n+              pcVar7 = (code *)(uint)CONCAT11(*(undefined *)(iVar3 + 2),*(undefined *)(iVar3 + 3));\n+              if ((pcVar7 < (code *)0x4) || (pcVar8 < pcVar7)) goto LAB_0;\n+              iStack_2c = iRam00000000;\n+              pcStack_30 = pcVar8;\n+              (*(code *)0x0)(0,0x490,iVar3);\n+              cVar1 = *(char *)(iVar3 + 4);\n+              if (cVar1 == '\\x03') {\n+                if (*(int *)(iStack_2c + 0xbc) == 0) {\n+                  if ((iRam00000000 != 0) && (*(code **)(iRam00000000 + 0x11c) != (code *)0x0)) {\n+                    pcStack_30 = *(code **)(iRam00000000 + 0x11c);\n+                    uVar6 = (**(code **)(iRam00000000 + 0x120))();\n+                    (*pcStack_30)(3,8,0x4cc,uVar6,8);\n+                  }\n+                  goto LAB_1;\n+                }\n+                (*(code *)0x0)();\n+                (**(code **)(iRam00000000 + 0xa0))(*(undefined4 *)(iStack_2c + 0xbc));\n+                iVar3 = iRam00000000;\n+                *(undefined4 *)(iStack_2c + 0xbc) = 0;\n+                if ((iVar3 != 0) && (*(code **)(iVar3 + 0x11c) != (code *)0x0)) {\n+                  pcStack_30 = *(code **)(iVar3 + 0x11c);\n+                  uVar6 = (**(code **)(iVar3 + 0x120))();\n+                  (*pcStack_30)(3,8,0x4ac,uVar6,8);\n+                }\n+                if (iRam00000000 != 0) {\n+                  *(undefined *)(iRam00000000 + 0xb2) = 2;\n+                  memw();\n+                  (*(code *)0x0)(2);\n+                  uVar6 = 0;\n+                  goto LAB_2;\n+                }\n+                goto LAB_0;\n+              }\n+              if (cVar1 == '\\x04') {\n+                if ((iRam00000000 != 0) && (*(code **)(iRam00000000 + 0x11c) != (code *)0x0)) {\n+                  pcStack_30 = *(code **)(iRam00000000 + 0x11c);\n+                  uVar6 = (**(code **)(iRam00000000 + 0x120))();\n+                  (*pcStack_30)(3,8,0x524,uVar6,8);\n+                }\n+LAB_1:\n+                if (iRam00000000 == 0) goto LAB_0;\n+                *(undefined *)(iRam00000000 + 0xb2) = 3;\n+                memw();\n+                (*(code *)0x0)(3);\n+                uVar6 = 0;\n               }\n               else {\n-                pcStack_28 = pcRam00000000;\n-                pcStack_2c = pcVar8;\n-                (*(code *)0x0)(0,0x45c,pcVar8);\n-                cVar1 = pcStack_2c[4];\n-                if (cVar1 == (code)0x3) {\n-                  (*(code *)0x0)(*(undefined4 *)(pcStack_28 + 0xbc));\n-                  (**(code **)(pcRam00000000 + 0xa0))(*(undefined4 *)(pcStack_28 + 0xbc));\n-                  pcVar8 = pcRam00000000;\n-                  *(undefined4 *)(pcStack_28 + 0xbc) = 0;\n-                  if ((pcVar8 != (code *)0x0) && (*(code **)(pcVar8 + 0x11c) != (code *)0x0)) {\n-                    pcStack_2c = *(code **)(pcVar8 + 0x11c);\n-                    uVar5 = (**(code **)(pcVar8 + 0x120))();\n-                    (*pcStack_2c)(3,8,0x478,uVar5,8);\n-                  }\n-                  uVar7 = 0;\n-                  pcStack_28[0xb2] = (code)0x1;\n-                  memw();\n-                }\n-                else if (cVar1 == (code)0x4) {\n-                  if ((pcRam00000000 != (code *)0x0) &&\n-                     (*(code **)(pcRam00000000 + 0x11c) != (code *)0x0)) {\n-                    pcStack_2c = *(code **)(pcRam00000000 + 0x11c);\n-                    uVar5 = (**(code **)(pcRam00000000 + 0x120))();\n-                    (*pcStack_2c)(3,8,0x498,uVar5,8);\n-                  }\n-                  uVar7 = 0;\n-                  pcStack_28[0xb2] = (code)0x2;\n-                  memw();\n-                }\n-                else {\n-                  if (cVar1 != (code)0x1) goto LAB_0;\n-                  uVar7 = (*(code *)0x0)(pcStack_2c + 4,uVar7);\n-                  (*(code *)0x0)(pcStack_28,uVar7);\n-                }\n+                if (cVar1 != '\\x01') goto LAB_0;\n+                uVar6 = (*(code *)0x0)(iVar3 + 4,pcStack_30);\n+                (*(code *)0x0)(iStack_2c,uVar6);\n               }\n             }\n-            (*(code *)0x0)(uVar7);\n-            pcVar8 = *(code **)(iVar3 + 0xc);\n+            else {\n+LAB_0:\n+              uVar6 = 0;\n+            }\n+LAB_2:\n+            (*(code *)0x0)(uVar6);\n+            iVar3 = *(int *)(iVar5 + 0xc);\n           }\n-          (**(code **)(pcRam00000000 + 0xa0))(pcVar8);\n-          (**(code **)(pcRam00000000 + 0xa0))(iVar3);\n+          (**(code **)(iRam00000000 + 0xa0))(iVar3);\n+          (**(code **)(iRam00000000 + 0xa0))(iVar5);\n         }\n+LAB_3:\n+        (**(code **)(iRam00000000 + 0xa0))(piStack_34);\n       }\n       else {\n-        if (iVar3 != 0) {\n-          if (iVar3 == 2) {\n-            (**(code **)(pcRam00000000 + 0xa0))();\n-            (**(code **)(pcRam00000000 + 0x50))(pcRam00000000);\n-            pcVar2 = pcRam00000000;\n-            pcRam00000000 = (code *)0x0;\n-            if (pcVar2 != (code *)0x0) {\n-              (*pcRam00000030)();\n+        if (iVar3 == 0) {\n+          *(char *)(iVar2 + 0xaf) = *(char *)(iVar2 + 0xaf) + -1;\n+          memw();\n+          if (iVar5 != 0) {\n+            iVar3 = (*(code *)0x0)(auStack_40);\n+            if (iVar3 == 0) {\n+              iVar3 = (*(code *)0x0)(iVar5,1,0x48c,0,&pcStack_38,0);\n+              if (iVar3 != 0) {\n+                if (iRam00000000 != 0) {\n+                  *(undefined *)(iRam00000000 + 0xb2) = 1;\n+                  iStack_2c = iVar3;\n+                  (*(code *)0x0)(1);\n+                  iVar3 = iStack_2c;\n+                }\n+                iVar4 = iVar3 + -0xe;\n+                pcStack_30 = pcStack_38;\n+                iStack_2c = iVar3;\n+                (*(code *)0x0)(iVar4,auStack_40,6);\n+                (*(code *)0x0)(iStack_2c + -8,iVar5 + 0xa9,6);\n+                *(undefined *)(iVar3 + -2) = 0x88;\n+                *(undefined *)(iVar3 + -1) = 0x8e;\n+                memw();\n+                (*(code *)0x0)(0,iVar4,(uint)(pcStack_30 + 0xe) & 0xffff);\n+                (**(code **)(iRam00000000 + 0xa0))(iVar4);\n+              }\n             }\n-            (**(code **)((int)pcRam00000000 + 0x88))(0);\n-            return;\n-          }\n-          (**(code **)(pcRam00000000 + 0xa0))();\n-          goto LAB_1;\n-        }\n-        pcVar2[0xaf] = (code)((char)pcVar2[0xaf] + -1);\n-        memw();\n-        if (pcVar8 != (code *)0x0) {\n-          pcVar4 = (code *)(*(code *)0x0)(auStack_40);\n-          if (pcVar4 == (code *)0x0) {\n-            pcStack_28 = pcVar4;\n-            iVar3 = (*(code *)0x0)(pcVar8,1,0x458,0,&pcStack_38,0);\n-            if (iVar3 != 0) {\n-              iStack_30 = iVar3;\n-              (*(code *)0x0)(4);\n-              iVar3 = iStack_30;\n-              iVar6 = iStack_30 + -0xe;\n-              pcStack_2c = pcStack_38;\n-              (*(code *)0x0)(iVar6,auStack_40,6);\n-              (*(code *)0x0)(iStack_30 + -8,pcVar8 + 0xa9,6);\n-              *(undefined *)(iVar3 + -2) = 0x88;\n-              *(undefined *)(iVar3 + -1) = 0x8e;\n-              memw();\n-              (*(code *)0x0)(pcStack_28,iVar6,(uint)(pcStack_2c + 0xe) & 0xffff);\n-              (**(code **)(pcRam00000000 + 0xa0))(iVar6);\n+            else if ((iRam00000000 != 0) && (*(code **)(iRam00000000 + 0x11c) != (code *)0x0)) {\n+              pcStack_30 = *(code **)(iRam00000000 + 0x11c);\n+              uVar6 = (**(code **)(iRam00000000 + 0x120))();\n+              (*pcStack_30)(1,8,0x470,uVar6,8);\n             }\n           }\n-          else if ((pcRam00000000 != (code *)0x0) &&\n-                  (*(code **)(pcRam00000000 + 0x11c) != (code *)0x0)) {\n-            pcStack_28 = *(code **)(pcRam00000000 + 0x11c);\n-            uVar5 = (**(code **)(pcRam00000000 + 0x120))();\n-            (*pcStack_28)(1,8,0x43c,uVar5,8);\n+          goto LAB_3;\n+        }\n+        if (iVar3 == 2) {\n+          (**(code **)(iRam00000000 + 0xa0))();\n+          (**(code **)(iRam00000000 + 0x50))(iRam00000000);\n+          iVar2 = iRam00000000;\n+          iRam00000000 = 0;\n+          if (iVar2 != 0) {\n+            (*pcRam00000030)();\n           }\n+          (**(code **)(iRam00000000 + 0x88))(0);\n+          return;\n         }\n+        (**(code **)(iRam00000000 + 0xa0))();\n       }\n-      (**(code **)(pcRam00000000 + 0xa0))(piStack_34);\n     }\n-LAB_1:\n-    if (pcRam00000000 != (code *)0x0) {\n-      (**(code **)(pcRam00000000 + 0x30))();\n+    if (iRam00000000 != 0) {\n+      (**(code **)(iRam00000000 + 0x30))();\n     }\n   } while( true );\n }\n \n",
                "diff_type": [
                    "code",
                    "length",
                    "address"
                ],
                "ratio": 0.23,
                "i_ratio": 0.38,
                "m_ratio": 0.6,
                "b_ratio": 0.45,
                "match_types": [
                    "SymbolsHash"
                ]
            },
            {
                "old": {
                    "name": "eap_sm_process_request",
                    "fullname": "eap_sm_process_request",
                    "parent": "Global",
                    "refcount": 1,
                    "length": 528,
                    "called": [],
                    "calling": [],
                    "paramcount": 0,
                    "address": "00010e38",
                    "sig": "undefined eap_sm_process_request(void)",
                    "code": "\nint eap_sm_process_request(int *param_1,int param_2)\n\n{\n  uint uVar1;\n  undefined4 uVar2;\n  int iVar3;\n  int iVar4;\n  code *pcVar5;\n  uint *puVar6;\n  uint uVar7;\n  uint uVar8;\n  uint uVar9;\n  undefined auStack_30 [48];\n  \n  if (param_2 == 0) {\n    return -1;\n  }\n  if (*(uint *)(param_2 + 4) < 4) {\n    return -1;\n  }\n  iVar4 = *(int *)(param_2 + 8);\n  if (*(int *)(param_2 + 8) == 0) {\n    iVar4 = param_2 + 0xc;\n  }\n  uVar7 = (uint)CONCAT11(*(undefined *)(iVar4 + 2),*(undefined *)(iVar4 + 3));\n  if (*(uint *)(param_2 + 4) < uVar7) {\n    return -1;\n  }\n  if (*(char *)(param_1 + 0x2a) == *(char *)(iVar4 + 1)) {\n    iVar4 = param_1[0x31];\n  }\n  else {\n    *(char *)(param_1 + 0x2a) = *(char *)(iVar4 + 1);\n    memw();\n    uVar1 = (uint)*(byte *)(iVar4 + 4);\n    if (uVar1 == 1) {\n      if (pcRam0000005c == (code *)0x0) goto LAB_00010e8c;\n      iVar4 = (*pcRam0000005c)(param_1,*(undefined *)(iVar4 + 1),0);\n    }\n    else {\n      if (uVar1 == 2) {\n        return 0;\n      }\n      uVar8 = 0;\n      uVar9 = uVar1;\n      if (uVar1 == 0xfe) {\n        if (uVar7 < 0xc) {\n          return -1;\n        }\n        uVar9 = (uint)*(byte *)(iVar4 + 8) << 0x18 | (uint)*(byte *)(iVar4 + 9) << 0x10 |\n                (uint)*(byte *)(iVar4 + 0xb) | (uint)*(byte *)(iVar4 + 10) << 8;\n        uVar8 = (uint)*(byte *)(iVar4 + 5) << 0x10 | (uint)*(byte *)(iVar4 + 6) << 8 |\n                (uint)*(byte *)(iVar4 + 7);\n      }\n      puVar6 = (uint *)param_1[0x32];\n      if ((((puVar6 == (uint *)0x0) || (*param_1 == 0)) || (uVar8 != *puVar6)) ||\n         (uVar9 != puVar6[1])) {\n        if ((pcRam00000050 != (code *)0x0) && (iVar3 = (*pcRam00000050)(), iVar3 != 0)) {\n          if ((param_1[0x32] != 0) && (pcRam0000004c != (code *)0x0)) {\n            (*pcRam0000004c)(param_1,0x3cc);\n          }\n          pcVar5 = *(code **)(iVar3 + 0x10);\n          param_1[0x32] = iVar3;\n          iVar3 = (*pcVar5)(param_1);\n          *param_1 = iVar3;\n          if (iVar3 != 0) {\n            iVar4 = (**(code **)(param_1[0x32] + 0x18))(param_1,iVar3,auStack_30,param_2);\n            goto LAB_00010f92;\n          }\n          if ((iRam00000000 != 0) &&\n             (pcVar5 = *(code **)(iRam00000000 + 0x11c), pcVar5 != (code *)0x0)) {\n            uVar2 = (**(code **)(iRam00000000 + 0x120))();\n            (*pcVar5)(1,8,0x3d8,uVar2,8);\n          }\n          param_1[0x32] = 0;\n        }\n        if (pcRam00000058 == (code *)0x0) {\n          return -1;\n        }\n        iVar4 = (*pcRam00000058)(param_1,uVar1,*(undefined *)(iVar4 + 1));\n        if (iVar4 == 0) {\n          return -1;\n        }\n        goto LAB_0001100c;\n      }\n      iVar4 = (*(code *)puVar6[6])(param_1,*param_1,auStack_30,param_2);\nLAB_00010f92:\n      pcVar5 = *(code **)(param_1[0x32] + 0x1c);\n      if (((pcVar5 != (code *)0x0) && (*(int *)(param_1[0x32] + 0x20) != 0)) &&\n         (iVar3 = (*pcVar5)(param_1,*param_1), iVar3 != 0)) {\n        (**(code **)(iRam00000000 + 0xa0))(param_1[0x2f]);\n        iVar3 = (**(code **)(param_1[0x32] + 0x20))(param_1,*param_1,param_1 + 0x30);\n        param_1[0x2f] = iVar3;\n      }\n    }\n  }\n  if (iVar4 == 0) {\nLAB_00010e8c:\n    if ((iRam00000000 != 0) && (pcVar5 = *(code **)(iRam00000000 + 0x11c), pcVar5 != (code *)0x0)) {\n      uVar2 = (**(code **)(iRam00000000 + 0x120))();\n      (*pcVar5)(1,8,0x410,uVar2,8);\n    }\n    return -1;\n  }\nLAB_0001100c:\n  iVar3 = (*(code *)0x0)(param_1,iVar4);\n  if (iVar3 != 0) {\n    (*(code *)0x0)();\n    param_1[0x31] = 0;\n    (*(code *)0x0)(iVar4);\n    if (iVar3 == -2) {\n      *(undefined *)((int)param_1 + 0xb2) = 2;\n      memw();\n      iVar3 = 2;\n    }\n    return iVar3;\n  }\n  if (param_1[0x31] == iVar4) {\n    return 0;\n  }\n  (*(code *)0x0)();\n  param_1[0x31] = iVar4;\n  return 0;\n}\n\n",
                    "instructions": 4351734818090850169,
                    "mnemonics": -1071352597689409813,
                    "blocks": -8161882361319123558,
                    "sym_type": "Function",
                    "sym_source": "IMPORTED",
                    "external": false
                },
                "new": {
                    "name": "eap_sm_process_request",
                    "fullname": "eap_sm_process_request",
                    "parent": "Global",
                    "refcount": 1,
                    "length": 669,
                    "called": [],
                    "calling": [],
                    "paramcount": 0,
                    "address": "00010ecc",
                    "sig": "undefined eap_sm_process_request(void)",
                    "code": "\nint eap_sm_process_request(int *param_1,int param_2)\n\n{\n  undefined4 uVar1;\n  int iVar2;\n  int iVar3;\n  code *pcVar4;\n  uint uVar5;\n  uint uVar6;\n  uint *puVar7;\n  uint uVar8;\n  uint uVar9;\n  undefined4 uVar10;\n  undefined auStack_30 [48];\n  \n  if (param_2 == 0) {\n    return -1;\n  }\n  if (*(uint *)(param_2 + 4) < 4) {\n    return -1;\n  }\n  iVar3 = *(int *)(param_2 + 8);\n  if (*(int *)(param_2 + 8) == 0) {\n    iVar3 = param_2 + 0xc;\n  }\n  uVar6 = (uint)CONCAT11(*(undefined *)(iVar3 + 2),*(undefined *)(iVar3 + 3));\n  if (*(uint *)(param_2 + 4) < uVar6) {\n    return -1;\n  }\n  if (*(char *)(param_1 + 0x2a) == *(char *)(iVar3 + 1)) {\n    iVar3 = param_1[0x31];\nLAB_000110d1:\n    if (iVar3 != 0) {\nLAB_000110f8:\n      iVar2 = (*(code *)0x0)(param_1,iVar3);\n      if (iVar2 == 0) {\n        if (param_1[0x31] == iVar3) {\n          return 0;\n        }\n        (*(code *)0x0)();\n        param_1[0x31] = iVar3;\n        return 0;\n      }\n      (*(code *)0x0)();\n      param_1[0x31] = 0;\n      (*(code *)0x0)(iVar3);\n      if ((iVar2 == -2) && (iVar2 = 3, iRam00000000 != 0)) {\n        *(undefined *)(iRam00000000 + 0xb2) = 3;\n        memw();\n        (*(code *)0x0)(3);\n        return 3;\n      }\n      return iVar2;\n    }\n  }\n  else {\n    *(char *)(param_1 + 0x2a) = *(char *)(iVar3 + 1);\n    memw();\n    uVar5 = (uint)*(byte *)(iVar3 + 4);\n    if (uVar5 != 1) {\n      if (uVar5 == 2) {\n        return 0;\n      }\n      uVar8 = 0;\n      uVar9 = uVar5;\n      if (uVar5 == 0xfe) {\n        if (uVar6 < 0xc) {\n          return -1;\n        }\n        uVar9 = (uint)*(byte *)(iVar3 + 8) << 0x18 | (uint)*(byte *)(iVar3 + 9) << 0x10 |\n                (uint)*(byte *)(iVar3 + 0xb) | (uint)*(byte *)(iVar3 + 10) << 8;\n        uVar8 = (uint)*(byte *)(iVar3 + 5) << 0x10 | (uint)*(byte *)(iVar3 + 6) << 8 |\n                (uint)*(byte *)(iVar3 + 7);\n      }\n      puVar7 = (uint *)param_1[0x32];\n      if ((((puVar7 == (uint *)0x0) || (*param_1 == 0)) || (uVar8 != *puVar7)) ||\n         (uVar9 != puVar7[1])) {\n        if ((pcRam00000050 != (code *)0x0) && (iVar2 = (*pcRam00000050)(), iVar2 != 0)) {\n          if ((param_1[0x32] != 0) && (pcRam0000004c != (code *)0x0)) {\n            (*pcRam0000004c)(param_1,0x400);\n          }\n          pcVar4 = *(code **)(iVar2 + 0x10);\n          param_1[0x32] = iVar2;\n          iVar2 = (*pcVar4)(param_1);\n          *param_1 = iVar2;\n          if (iVar2 != 0) {\n            puVar7 = (uint *)param_1[0x32];\n            if ((code *)puVar7[6] == (code *)0x0) {\n              if (iRam00000000 != 0) {\n                pcVar4 = *(code **)(iRam00000000 + 0x11c);\n                if (pcVar4 != (code *)0x0) {\n                  uVar1 = (**(code **)(iRam00000000 + 0x120))();\n                  uVar10 = 0x194;\n                  goto LAB_00011065;\n                }\n                goto LAB_00011162;\n              }\n              goto LAB_0001116a;\n            }\n            iVar3 = (*(code *)puVar7[6])(param_1,iVar2,auStack_30,param_2);\n            goto LAB_00011080;\n          }\n          if ((iRam00000000 != 0) &&\n             (pcVar4 = *(code **)(iRam00000000 + 0x11c), pcVar4 != (code *)0x0)) {\n            uVar1 = (**(code **)(iRam00000000 + 0x120))();\n            (*pcVar4)(1,8,0x40c,uVar1,8);\n          }\n          param_1[0x32] = 0;\n        }\n        if (pcRam00000058 == (code *)0x0) {\n          return -1;\n        }\n        iVar3 = (*pcRam00000058)(param_1,uVar5,*(undefined *)(iVar3 + 1));\n        if (iVar3 == 0) {\n          return -1;\n        }\n        goto LAB_000110f8;\n      }\n      if ((code *)puVar7[6] == (code *)0x0) {\n        if (iRam00000000 == 0) {\nLAB_0001116a:\n          pcVar4 = (code *)puVar7[7];\n          if (pcVar4 == (code *)0x0) {\n            return -1;\n          }\n        }\n        else {\n          pcVar4 = *(code **)(iRam00000000 + 0x11c);\n          if (pcVar4 == (code *)0x0) {\nLAB_00011162:\n            pcVar4 = (code *)puVar7[7];\n            if (pcVar4 == (code *)0x0) goto LAB_000110d9;\n          }\n          else {\n            uVar1 = (**(code **)(iRam00000000 + 0x120))();\n            uVar10 = 0x17d;\nLAB_00011065:\n            (*pcVar4)(1,8,0x3cc,uVar1,8,uVar10);\n            puVar7 = (uint *)param_1[0x32];\n            pcVar4 = (code *)puVar7[7];\n            if (pcVar4 == (code *)0x0) goto LAB_00010f27;\n          }\n        }\n        iVar3 = 0;\n        if (puVar7[8] == 0) goto LAB_00010f27;\n      }\n      else {\n        iVar3 = (*(code *)puVar7[6])(param_1,*param_1,auStack_30,param_2);\nLAB_00011080:\n        pcVar4 = *(code **)(param_1[0x32] + 0x1c);\n        if ((pcVar4 == (code *)0x0) || (*(int *)(param_1[0x32] + 0x20) == 0)) goto LAB_000110d1;\n      }\n      iVar2 = (*pcVar4)(param_1,*param_1);\n      if (iVar2 != 0) {\n        (**(code **)(iRam00000000 + 0xa0))(param_1[0x2f]);\n        iVar2 = (**(code **)(param_1[0x32] + 0x20))(param_1,*param_1,param_1 + 0x30);\n        param_1[0x2f] = iVar2;\n      }\n      goto LAB_000110d1;\n    }\n    if (pcRam0000005c != (code *)0x0) {\n      iVar3 = (*pcRam0000005c)(param_1,*(undefined *)(iVar3 + 1),0);\n      goto LAB_000110d1;\n    }\n  }\nLAB_00010f27:\n  if (iRam00000000 == 0) {\n    return -1;\n  }\nLAB_000110d9:\n  pcVar4 = *(code **)(iRam00000000 + 0x11c);\n  if (pcVar4 != (code *)0x0) {\n    uVar1 = (**(code **)(iRam00000000 + 0x120))();\n    (*pcVar4)(1,8,0x444,uVar1,8);\n  }\n  return -1;\n}\n\n",
                    "instructions": 1773730437309949446,
                    "mnemonics": -8412670792037289359,
                    "blocks": -8954756289000389347,
                    "sym_type": "Function",
                    "sym_source": "IMPORTED",
                    "external": false
                },
                "diff": "--- eap_sm_process_request\n+++ eap_sm_process_request\n@@ -1,126 +1,179 @@\n \n int eap_sm_process_request(int *param_1,int param_2)\n \n {\n-  uint uVar1;\n-  undefined4 uVar2;\n+  undefined4 uVar1;\n+  int iVar2;\n   int iVar3;\n-  int iVar4;\n-  code *pcVar5;\n-  uint *puVar6;\n-  uint uVar7;\n+  code *pcVar4;\n+  uint uVar5;\n+  uint uVar6;\n+  uint *puVar7;\n   uint uVar8;\n   uint uVar9;\n+  undefined4 uVar10;\n   undefined auStack_30 [48];\n   \n   if (param_2 == 0) {\n     return -1;\n   }\n   if (*(uint *)(param_2 + 4) < 4) {\n     return -1;\n   }\n-  iVar4 = *(int *)(param_2 + 8);\n+  iVar3 = *(int *)(param_2 + 8);\n   if (*(int *)(param_2 + 8) == 0) {\n-    iVar4 = param_2 + 0xc;\n+    iVar3 = param_2 + 0xc;\n   }\n-  uVar7 = (uint)CONCAT11(*(undefined *)(iVar4 + 2),*(undefined *)(iVar4 + 3));\n-  if (*(uint *)(param_2 + 4) < uVar7) {\n+  uVar6 = (uint)CONCAT11(*(undefined *)(iVar3 + 2),*(undefined *)(iVar3 + 3));\n+  if (*(uint *)(param_2 + 4) < uVar6) {\n     return -1;\n   }\n-  if (*(char *)(param_1 + 0x2a) == *(char *)(iVar4 + 1)) {\n-    iVar4 = param_1[0x31];\n+  if (*(char *)(param_1 + 0x2a) == *(char *)(iVar3 + 1)) {\n+    iVar3 = param_1[0x31];\n+LAB_0:\n+    if (iVar3 != 0) {\n+LAB_1:\n+      iVar2 = (*(code *)0x0)(param_1,iVar3);\n+      if (iVar2 == 0) {\n+        if (param_1[0x31] == iVar3) {\n+          return 0;\n+        }\n+        (*(code *)0x0)();\n+        param_1[0x31] = iVar3;\n+        return 0;\n+      }\n+      (*(code *)0x0)();\n+      param_1[0x31] = 0;\n+      (*(code *)0x0)(iVar3);\n+      if ((iVar2 == -2) && (iVar2 = 3, iRam00000000 != 0)) {\n+        *(undefined *)(iRam00000000 + 0xb2) = 3;\n+        memw();\n+        (*(code *)0x0)(3);\n+        return 3;\n+      }\n+      return iVar2;\n+    }\n   }\n   else {\n-    *(char *)(param_1 + 0x2a) = *(char *)(iVar4 + 1);\n+    *(char *)(param_1 + 0x2a) = *(char *)(iVar3 + 1);\n     memw();\n-    uVar1 = (uint)*(byte *)(iVar4 + 4);\n-    if (uVar1 == 1) {\n-      if (pcRam0000005c == (code *)0x0) goto LAB_0;\n-      iVar4 = (*pcRam0000005c)(param_1,*(undefined *)(iVar4 + 1),0);\n-    }\n-    else {\n-      if (uVar1 == 2) {\n+    uVar5 = (uint)*(byte *)(iVar3 + 4);\n+    if (uVar5 != 1) {\n+      if (uVar5 == 2) {\n         return 0;\n       }\n       uVar8 = 0;\n-      uVar9 = uVar1;\n-      if (uVar1 == 0xfe) {\n-        if (uVar7 < 0xc) {\n+      uVar9 = uVar5;\n+      if (uVar5 == 0xfe) {\n+        if (uVar6 < 0xc) {\n           return -1;\n         }\n-        uVar9 = (uint)*(byte *)(iVar4 + 8) << 0x18 | (uint)*(byte *)(iVar4 + 9) << 0x10 |\n-                (uint)*(byte *)(iVar4 + 0xb) | (uint)*(byte *)(iVar4 + 10) << 8;\n-        uVar8 = (uint)*(byte *)(iVar4 + 5) << 0x10 | (uint)*(byte *)(iVar4 + 6) << 8 |\n-                (uint)*(byte *)(iVar4 + 7);\n+        uVar9 = (uint)*(byte *)(iVar3 + 8) << 0x18 | (uint)*(byte *)(iVar3 + 9) << 0x10 |\n+                (uint)*(byte *)(iVar3 + 0xb) | (uint)*(byte *)(iVar3 + 10) << 8;\n+        uVar8 = (uint)*(byte *)(iVar3 + 5) << 0x10 | (uint)*(byte *)(iVar3 + 6) << 8 |\n+                (uint)*(byte *)(iVar3 + 7);\n       }\n-      puVar6 = (uint *)param_1[0x32];\n-      if ((((puVar6 == (uint *)0x0) || (*param_1 == 0)) || (uVar8 != *puVar6)) ||\n-         (uVar9 != puVar6[1])) {\n-        if ((pcRam00000050 != (code *)0x0) && (iVar3 = (*pcRam00000050)(), iVar3 != 0)) {\n+      puVar7 = (uint *)param_1[0x32];\n+      if ((((puVar7 == (uint *)0x0) || (*param_1 == 0)) || (uVar8 != *puVar7)) ||\n+         (uVar9 != puVar7[1])) {\n+        if ((pcRam00000050 != (code *)0x0) && (iVar2 = (*pcRam00000050)(), iVar2 != 0)) {\n           if ((param_1[0x32] != 0) && (pcRam0000004c != (code *)0x0)) {\n-            (*pcRam0000004c)(param_1,0x3cc);\n+            (*pcRam0000004c)(param_1,0x400);\n           }\n-          pcVar5 = *(code **)(iVar3 + 0x10);\n-          param_1[0x32] = iVar3;\n-          iVar3 = (*pcVar5)(param_1);\n-          *param_1 = iVar3;\n-          if (iVar3 != 0) {\n-            iVar4 = (**(code **)(param_1[0x32] + 0x18))(param_1,iVar3,auStack_30,param_2);\n-            goto LAB_1;\n+          pcVar4 = *(code **)(iVar2 + 0x10);\n+          param_1[0x32] = iVar2;\n+          iVar2 = (*pcVar4)(param_1);\n+          *param_1 = iVar2;\n+          if (iVar2 != 0) {\n+            puVar7 = (uint *)param_1[0x32];\n+            if ((code *)puVar7[6] == (code *)0x0) {\n+              if (iRam00000000 != 0) {\n+                pcVar4 = *(code **)(iRam00000000 + 0x11c);\n+                if (pcVar4 != (code *)0x0) {\n+                  uVar1 = (**(code **)(iRam00000000 + 0x120))();\n+                  uVar10 = 0x194;\n+                  goto LAB_2;\n+                }\n+                goto LAB_3;\n+              }\n+              goto LAB_4;\n+            }\n+            iVar3 = (*(code *)puVar7[6])(param_1,iVar2,auStack_30,param_2);\n+            goto LAB_5;\n           }\n           if ((iRam00000000 != 0) &&\n-             (pcVar5 = *(code **)(iRam00000000 + 0x11c), pcVar5 != (code *)0x0)) {\n-            uVar2 = (**(code **)(iRam00000000 + 0x120))();\n-            (*pcVar5)(1,8,0x3d8,uVar2,8);\n+             (pcVar4 = *(code **)(iRam00000000 + 0x11c), pcVar4 != (code *)0x0)) {\n+            uVar1 = (**(code **)(iRam00000000 + 0x120))();\n+            (*pcVar4)(1,8,0x40c,uVar1,8);\n           }\n           param_1[0x32] = 0;\n         }\n         if (pcRam00000058 == (code *)0x0) {\n           return -1;\n         }\n-        iVar4 = (*pcRam00000058)(param_1,uVar1,*(undefined *)(iVar4 + 1));\n-        if (iVar4 == 0) {\n+        iVar3 = (*pcRam00000058)(param_1,uVar5,*(undefined *)(iVar3 + 1));\n+        if (iVar3 == 0) {\n           return -1;\n         }\n-        goto LAB_2;\n+        goto LAB_1;\n       }\n-      iVar4 = (*(code *)puVar6[6])(param_1,*param_1,auStack_30,param_2);\n-LAB_1:\n-      pcVar5 = *(code **)(param_1[0x32] + 0x1c);\n-      if (((pcVar5 != (code *)0x0) && (*(int *)(param_1[0x32] + 0x20) != 0)) &&\n-         (iVar3 = (*pcVar5)(param_1,*param_1), iVar3 != 0)) {\n+      if ((code *)puVar7[6] == (code *)0x0) {\n+        if (iRam00000000 == 0) {\n+LAB_4:\n+          pcVar4 = (code *)puVar7[7];\n+          if (pcVar4 == (code *)0x0) {\n+            return -1;\n+          }\n+        }\n+        else {\n+          pcVar4 = *(code **)(iRam00000000 + 0x11c);\n+          if (pcVar4 == (code *)0x0) {\n+LAB_3:\n+            pcVar4 = (code *)puVar7[7];\n+            if (pcVar4 == (code *)0x0) goto LAB_6;\n+          }\n+          else {\n+            uVar1 = (**(code **)(iRam00000000 + 0x120))();\n+            uVar10 = 0x17d;\n+LAB_2:\n+            (*pcVar4)(1,8,0x3cc,uVar1,8,uVar10);\n+            puVar7 = (uint *)param_1[0x32];\n+            pcVar4 = (code *)puVar7[7];\n+            if (pcVar4 == (code *)0x0) goto LAB_7;\n+          }\n+        }\n+        iVar3 = 0;\n+        if (puVar7[8] == 0) goto LAB_7;\n+      }\n+      else {\n+        iVar3 = (*(code *)puVar7[6])(param_1,*param_1,auStack_30,param_2);\n+LAB_5:\n+        pcVar4 = *(code **)(param_1[0x32] + 0x1c);\n+        if ((pcVar4 == (code *)0x0) || (*(int *)(param_1[0x32] + 0x20) == 0)) goto LAB_0;\n+      }\n+      iVar2 = (*pcVar4)(param_1,*param_1);\n+      if (iVar2 != 0) {\n         (**(code **)(iRam00000000 + 0xa0))(param_1[0x2f]);\n-        iVar3 = (**(code **)(param_1[0x32] + 0x20))(param_1,*param_1,param_1 + 0x30);\n-        param_1[0x2f] = iVar3;\n+        iVar2 = (**(code **)(param_1[0x32] + 0x20))(param_1,*param_1,param_1 + 0x30);\n+        param_1[0x2f] = iVar2;\n       }\n+      goto LAB_0;\n+    }\n+    if (pcRam0000005c != (code *)0x0) {\n+      iVar3 = (*pcRam0000005c)(param_1,*(undefined *)(iVar3 + 1),0);\n+      goto LAB_0;\n     }\n   }\n-  if (iVar4 == 0) {\n-LAB_0:\n-    if ((iRam00000000 != 0) && (pcVar5 = *(code **)(iRam00000000 + 0x11c), pcVar5 != (code *)0x0)) {\n-      uVar2 = (**(code **)(iRam00000000 + 0x120))();\n-      (*pcVar5)(1,8,0x410,uVar2,8);\n-    }\n+LAB_7:\n+  if (iRam00000000 == 0) {\n     return -1;\n   }\n-LAB_2:\n-  iVar3 = (*(code *)0x0)(param_1,iVar4);\n-  if (iVar3 != 0) {\n-    (*(code *)0x0)();\n-    param_1[0x31] = 0;\n-    (*(code *)0x0)(iVar4);\n-    if (iVar3 == -2) {\n-      *(undefined *)((int)param_1 + 0xb2) = 2;\n-      memw();\n-      iVar3 = 2;\n-    }\n-    return iVar3;\n+LAB_6:\n+  pcVar4 = *(code **)(iRam00000000 + 0x11c);\n+  if (pcVar4 != (code *)0x0) {\n+    uVar1 = (**(code **)(iRam00000000 + 0x120))();\n+    (*pcVar4)(1,8,0x444,uVar1,8);\n   }\n-  if (param_1[0x31] == iVar4) {\n-    return 0;\n-  }\n-  (*(code *)0x0)();\n-  param_1[0x31] = iVar4;\n-  return 0;\n+  return -1;\n }\n \n",
                "diff_type": [
                    "code",
                    "length",
                    "address"
                ],
                "ratio": 0.31,
                "i_ratio": 0.31,
                "m_ratio": 0.59,
                "b_ratio": 0.58,
                "match_types": [
                    "SymbolsHash"
                ]
            }
        ]
    },
    "old_meta": {
        "Program Name": "wpa2_internal_old.o",
        "Language ID": "Xtensa:LE:32:default (4.0)",
        "Compiler ID": "default",
        "Processor": "Xtensa",
        "Endian": "Little",
        "Address Size": "32",
        "Minimum Address": "00010000",
        "Maximum Address": "_elfSectionHeaders::00000ac7",
        "# of Bytes": "24605",
        "# of Memory Blocks": "52",
        "# of Instructions": "987",
        "# of Defined Data": "268",
        "# of Functions": "10",
        "# of Symbols": "53",
        "# of Data Types": "30",
        "# of Data Type Categories": "2",
        "Analyzed": "true",
        "Created With Ghidra Version": "11.0",
        "Date Created": "Fri Mar 29 20:03:41 CST 2024",
        "ELF File Type": "relocatable",
        "ELF Original Image Base": "0x0",
        "ELF Prelinked": "false",
        "Elf Comment[0]": "",
        "Elf Comment[1]": "GCC: (crosstool-NG crosstool-ng-1.22.0-78-g4b87650) 5.2.0",
        "Executable Format": "Executable and Linking Format (ELF)",
        "Executable Location": "/data/git/esp/CVE-2019-12586-7/ghidriffs/wpa2_internal_old.o",
        "Executable MD5": "f799e287e6642322ec8ca45689fcfd86",
        "Executable SHA256": "ee0a7f244216a70a2c43f1eeb28dd2cf182649ffa575290c976463e25910b69d",
        "FSRL": "file:///data/git/esp/CVE-2019-12586-7/ghidriffs/wpa2_internal_old.o?MD5=f799e287e6642322ec8ca45689fcfd86",
        "Preferred Root Namespace Category": "",
        "Relocatable": "true",
        "Should Ask To Analyze": "false"
    },
    "new_meta": {
        "Program Name": "wpa2_internal_new.o",
        "Language ID": "Xtensa:LE:32:default (4.0)",
        "Compiler ID": "default",
        "Processor": "Xtensa",
        "Endian": "Little",
        "Address Size": "32",
        "Minimum Address": "00010000",
        "Maximum Address": "_elfSectionHeaders::00000a4f",
        "# of Bytes": "25654",
        "# of Memory Blocks": "50",
        "# of Instructions": "1058",
        "# of Defined Data": "272",
        "# of Functions": "10",
        "# of Symbols": "53",
        "# of Data Types": "31",
        "# of Data Type Categories": "2",
        "Analyzed": "true",
        "Created With Ghidra Version": "11.0",
        "Date Created": "Fri Mar 29 20:03:42 CST 2024",
        "ELF File Type": "relocatable",
        "ELF Original Image Base": "0x0",
        "ELF Prelinked": "false",
        "Elf Comment[0]": "",
        "Elf Comment[1]": "GCC: (crosstool-NG crosstool-ng-1.22.0-78-g4b87650) 5.2.0",
        "Executable Format": "Executable and Linking Format (ELF)",
        "Executable Location": "/data/git/esp/CVE-2019-12586-7/ghidriffs/wpa2_internal_new.o",
        "Executable MD5": "91e0c69a6219f27347ebca041605dd87",
        "Executable SHA256": "1b744a64b6455bb94a50ae9689a7ef37f5f8b90262163e2fe8bed744d2583cee",
        "FSRL": "file:///data/git/esp/CVE-2019-12586-7/ghidriffs/wpa2_internal_new.o?MD5=91e0c69a6219f27347ebca041605dd87",
        "Preferred Root Namespace Category": "",
        "Relocatable": "true",
        "Should Ask To Analyze": "false"
    },
    "md_credits": "\n<sub>Generated with `ghidriff` version: 0.6.0 on 2024-03-29T20:03:45</sub>",
    "html_credits": "\n<sub>Generated with <code>ghidriff</code> version: 0.6.0 on 2024-03-29T20:03:45</sub>"
}